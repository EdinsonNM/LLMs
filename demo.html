<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>LLM Visualization - Prototipo de Tesis</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        background: #0a0a0a;
        color: #fff;
        overflow: hidden;
      }

      #canvas-container {
        position: relative;
        width: 100vw;
        height: 100vh;
      }

      #controls {
        position: absolute;
        top: 20px;
        left: 20px;
        background: rgba(20, 20, 20, 0.9);
        padding: 20px;
        border-radius: 10px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        max-width: 300px;
        transition: all 0.3s;
      }

      #mode-selector {
        display: flex;
        gap: 10px;
        margin-bottom: 20px;
      }

      .mode-btn {
        flex: 1;
        padding: 10px;
        background: rgba(74, 158, 255, 0.2);
        border: 1px solid #4a9eff;
        color: #4a9eff;
        border-radius: 5px;
        cursor: pointer;
        transition: all 0.3s;
        font-size: 12px;
      }

      .mode-btn.active {
        background: #4a9eff;
        color: #000;
      }

      .control-group {
        margin-bottom: 15px;
      }

      .control-group label {
        display: block;
        margin-bottom: 5px;
        font-size: 12px;
        opacity: 0.8;
      }

      .slider {
        width: 100%;
        -webkit-appearance: none;
        height: 5px;
        border-radius: 5px;
        background: rgba(255, 255, 255, 0.1);
        outline: none;
      }

      .slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 15px;
        height: 15px;
        border-radius: 50%;
        background: #4a9eff;
        cursor: pointer;
      }

      #info-panel {
        position: absolute;
        top: 20px;
        right: 20px;
        background: rgba(20, 20, 20, 0.9);
        padding: 20px;
        border-radius: 10px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        max-width: 300px;
        transition: all 0.3s;
      }

      .metric {
        display: flex;
        justify-content: space-between;
        margin-bottom: 10px;
        font-size: 14px;
      }

      .metric-value {
        color: #4a9eff;
        font-weight: bold;
      }

      #tooltip {
        position: absolute;
        background: rgba(30, 30, 30, 0.95);
        padding: 10px 15px;
        border-radius: 5px;
        font-size: 14px;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s;
        border: 1px solid rgba(74, 158, 255, 0.3);
        max-width: 250px;
        z-index: 1000;
      }

      #input-simulation {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(20, 20, 20, 0.9);
        padding: 20px;
        border-radius: 10px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        width: 80%;
        max-width: 600px;
      }

      #text-input {
        width: 100%;
        padding: 10px;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 5px;
        color: #fff;
        font-size: 14px;
      }

      #process-btn {
        margin-top: 10px;
        padding: 10px 20px;
        background: #4a9eff;
        border: none;
        border-radius: 5px;
        color: #000;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s;
      }

      #process-btn:hover {
        background: #6ab0ff;
      }

      /* Estilos para modo estudiante */
      .student-mode #info-panel {
        background: rgba(20, 40, 20, 0.9);
        border: 1px solid rgba(100, 255, 100, 0.2);
      }

      .student-mode .metric-value {
        color: #4aff9e;
      }

      .student-help {
        display: none;
        background: rgba(74, 158, 255, 0.1);
        padding: 10px;
        margin-top: 10px;
        border-radius: 5px;
        font-size: 12px;
        line-height: 1.5;
      }

      .student-mode .student-help {
        display: block;
      }

      /* Panel de componentes */
      #component-selector {
        position: absolute;
        top: 50%;
        left: 20px;
        transform: translateY(-50%);
        background: rgba(20, 20, 20, 0.9);
        padding: 15px;
        border-radius: 10px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .component-btn {
        display: block;
        width: 100%;
        padding: 8px;
        margin-bottom: 5px;
        background: rgba(74, 158, 255, 0.2);
        border: 1px solid rgba(74, 158, 255, 0.5);
        color: #4a9eff;
        border-radius: 5px;
        cursor: pointer;
        font-size: 11px;
        transition: all 0.3s;
      }

      .component-btn.active {
        background: rgba(74, 158, 255, 0.5);
        border-color: #4a9eff;
      }

      .component-btn:hover {
        background: rgba(74, 158, 255, 0.3);
      }

      /* Estilos adicionales para modo investigador */
      .researcher-mode #controls {
        max-width: 350px;
      }

      .researcher-mode .advanced-controls {
        display: block !important;
      }

      .advanced-controls {
        display: none;
        margin-top: 20px;
        padding-top: 20px;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
      }

      .debug-info {
        font-family: "Courier New", monospace;
        font-size: 11px;
        background: rgba(0, 0, 0, 0.5);
        padding: 10px;
        border-radius: 5px;
        margin-top: 10px;
        max-height: 200px;
        overflow-y: auto;
      }
    </style>
  </head>
  <body>
    <div id="canvas-container">
      <canvas id="three-canvas"></canvas>
    </div>

    <div id="controls">
      <h3 style="margin-bottom: 15px">Modo de Visualizaci√≥n</h3>
      <div id="mode-selector">
        <button class="mode-btn active" data-mode="student">Estudiante</button>
        <button class="mode-btn" data-mode="researcher">Investigador</button>
      </div>

      <div class="control-group">
        <label for="layer-visibility">Capas Visibles</label>
        <input
          type="range"
          id="layer-visibility"
          class="slider"
          min="1"
          max="12"
          value="6"
        />
        <div class="student-help">
          üí° Las capas representan niveles de procesamiento. M√°s capas =
          comprensi√≥n m√°s profunda.
        </div>
      </div>

      <div class="control-group">
        <label for="animation-speed">Velocidad de Animaci√≥n</label>
        <input
          type="range"
          id="animation-speed"
          class="slider"
          min="0.1"
          max="2"
          step="0.1"
          value="1"
        />
      </div>

      <div class="control-group">
        <label for="connection-threshold">Umbral de Conexiones</label>
        <input
          type="range"
          id="connection-threshold"
          class="slider"
          min="0"
          max="1"
          step="0.1"
          value="0.5"
        />
        <div class="student-help">
          üí° Ajusta qu√© conexiones son lo suficientemente fuertes para
          mostrarse.
        </div>
      </div>

      <div class="advanced-controls">
        <h4 style="margin-bottom: 10px">Controles Avanzados</h4>
        <div class="control-group">
          <label for="attention-heads">Cabezas de Atenci√≥n</label>
          <input
            type="range"
            id="attention-heads"
            class="slider"
            min="1"
            max="16"
            value="8"
          />
        </div>
        <div class="control-group">
          <label for="embedding-dim">Dimensi√≥n de Embedding</label>
          <input
            type="range"
            id="embedding-dim"
            class="slider"
            min="128"
            max="1024"
            step="128"
            value="512"
          />
        </div>
        <div class="debug-info" id="debug-console">> Sistema inicializado</div>
      </div>
    </div>

    <div id="component-selector">
      <h4 style="margin-bottom: 10px; font-size: 12px">Componentes</h4>
      <button class="component-btn active" data-component="tokenizer">
        Tokenizador
      </button>
      <button class="component-btn active" data-component="embedding">
        Embedding
      </button>
      <button class="component-btn active" data-component="attention">
        Atenci√≥n
      </button>
      <button class="component-btn active" data-component="neural">
        Red Neural
      </button>
      <button class="component-btn active" data-component="output">
        Salida
      </button>
    </div>

    <div id="info-panel">
      <h3 style="margin-bottom: 15px">M√©tricas en Tiempo Real</h3>
      <div class="metric">
        <span>Tokens Procesados</span>
        <span class="metric-value" id="token-count">0</span>
      </div>
      <div class="metric">
        <span>Dimensi√≥n Embedding</span>
        <span class="metric-value" id="embedding-info">512D</span>
      </div>
      <div class="metric">
        <span>Atenci√≥n Activa</span>
        <span class="metric-value" id="attention-score">0%</span>
      </div>
      <div class="metric">
        <span>Neuronas Activas</span>
        <span class="metric-value" id="active-neurons">0</span>
      </div>
      <div class="metric">
        <span>Confianza Promedio</span>
        <span class="metric-value" id="confidence">0%</span>
      </div>
      <div class="metric">
        <span>Capas Procesadas</span>
        <span class="metric-value" id="layers-processed">0/12</span>
      </div>
      <div class="student-help">
        üí° Estas m√©tricas muestran qu√© tan activo est√° el modelo mientras
        procesa tu texto.
      </div>
    </div>

    <div id="input-simulation">
      <input
        type="text"
        id="text-input"
        placeholder="Escribe algo para visualizar el procesamiento..."
      />
      <button id="process-btn">Procesar Texto</button>
    </div>

    <div id="tooltip"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script>
      // Configuraci√≥n inicial
      let scene, camera, renderer;
      let components = {
        tokenizer: { group: null, visible: true },
        embedding: { group: null, visible: true },
        attention: { group: null, visible: true },
        neural: { group: null, visible: true },
        output: { group: null, visible: true },
      };
      let mode = "student";
      let animationSpeed = 1;
      let isProcessing = false;
      let raycaster, mouse;
      let hoveredObject = null;

      // Colores por componente
      const componentColors = {
        tokenizer: 0xff6b6b,
        embedding: 0x4ecdc4,
        attention: 0xffe66d,
        neural: 0x4a9eff,
        output: 0xa8e6cf,
      };

      // Inicializar Three.js
      function init() {
        // Escena
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x0a0a0a, 10, 50);

        // C√°mara
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(0, 0, 30);

        // Renderer
        renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById("three-canvas"),
          antialias: true,
          alpha: true,
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);

        // Controles de √≥rbita (paneo, zoom, rotaci√≥n)
        window.orbitControls = new THREE.OrbitControls(
          camera,
          renderer.domElement
        );
        orbitControls.enableDamping = true;
        orbitControls.dampingFactor = 0.08;
        orbitControls.screenSpacePanning = true;
        orbitControls.minDistance = 10;
        orbitControls.maxDistance = 80;
        orbitControls.enablePan = true;
        orbitControls.enableZoom = true;
        orbitControls.enableRotate = true;

        // Luces
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0x4a9eff, 1, 100);
        pointLight.position.set(0, 0, 20);
        scene.add(pointLight);

        // Crear componentes del LLM
        createLLMComponents();

        // Controles de rat√≥n
        //setupMouseControls();

        // Event listeners
        setupEventListeners();

        // Iniciar animaci√≥n
        animate();
      }

      function createLLMComponents() {
        // 1. Tokenizador
        createTokenizer();

        // 2. Capa de Embedding
        createEmbeddingLayer();

        // 3. Mecanismo de Atenci√≥n
        createAttentionMechanism();

        // 4. Red Neural Principal
        createNeuralNetwork();

        // 5. Capa de Salida
        createOutputLayer();
      }

      function createTokenizer() {
        const group = new THREE.Group();
        group.position.set(-30, 0, 0);

        // Crear tokens como cubos
        for (let i = 0; i < 8; i++) {
          const geometry = new THREE.BoxGeometry(1.5, 0.5, 0.5);
          const material = new THREE.MeshPhongMaterial({
            color: 0xff6b6b,
            emissive: 0xff6b6b,
            emissiveIntensity: 0,
          });

          const token = new THREE.Mesh(geometry, material);
          token.position.set(0, i * 1.5 - 5, 0);
          token.userData = {
            type: "token",
            index: i,
            component: "tokenizer",
          };

          group.add(token);
        }

        components.tokenizer.group = group;
        scene.add(group);
      }

      function createEmbeddingLayer() {
        const group = new THREE.Group();
        group.position.set(-20, 0, 0);

        // Crear un cubo 3D de puntos para el embedding
        const cubeSize = 5; // Tama√±o del cubo
        const pointsPerSide = 8; // N√∫mero de puntos por lado
        const spacing = cubeSize / (pointsPerSide - 1);

        // Crear puntos en un patr√≥n de cubo 3D
        for (let x = 0; x < pointsPerSide; x++) {
          for (let y = 0; y < pointsPerSide; y++) {
            for (let z = 0; z < pointsPerSide; z++) {
              const geometry = new THREE.SphereGeometry(0.1, 8, 8);
              const material = new THREE.MeshPhongMaterial({
                color: 0x4ecdc4,
                emissive: 0x4ecdc4,
                emissiveIntensity: 0,
                transparent: true,
                opacity: 0.8,
              });

              const point = new THREE.Mesh(geometry, material);

              // Posicionar el punto en el espacio 3D
              point.position.set(
                x * spacing - cubeSize / 2,
                y * spacing - cubeSize / 2,
                z * spacing - cubeSize / 2
              );

              point.userData = {
                type: "embedding",
                position: { x, y, z },
                component: "embedding",
                originalPosition: point.position.clone(),
              };

              group.add(point);
            }
          }
        }

        // A√±adir l√≠neas para mostrar la estructura del cubo
        const lineMaterial = new THREE.LineBasicMaterial({
          color: 0x4ecdc4,
          opacity: 0.2,
          transparent: true,
        });

        // Crear las aristas del cubo
        const cubeEdges = [
          // Cara frontal
          [0, 0, 0],
          [cubeSize / 2, 0, 0],
          [0, 0, 0],
          [0, cubeSize / 2, 0],
          [0, 0, 0],
          [0, 0, cubeSize / 2],
          // Cara trasera
          [cubeSize / 2, cubeSize / 2, cubeSize / 2],
          [-cubeSize / 2, cubeSize / 2, cubeSize / 2],
          [cubeSize / 2, cubeSize / 2, cubeSize / 2],
          [cubeSize / 2, -cubeSize / 2, cubeSize / 2],
          [cubeSize / 2, cubeSize / 2, cubeSize / 2],
          [cubeSize / 2, cubeSize / 2, -cubeSize / 2],
          // Conexiones
          [cubeSize / 2, 0, 0],
          [cubeSize / 2, cubeSize / 2, cubeSize / 2],
          [0, cubeSize / 2, 0],
          [cubeSize / 2, cubeSize / 2, cubeSize / 2],
          [0, 0, cubeSize / 2],
          [cubeSize / 2, cubeSize / 2, cubeSize / 2],
        ];

        cubeEdges.forEach((edge) => {
          const geometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(edge[0], edge[1], edge[2]),
            new THREE.Vector3(edge[3], edge[4], edge[5]),
          ]);
          const line = new THREE.Line(geometry, lineMaterial.clone());
          group.add(line);
        });

        components.embedding.group = group;
        scene.add(group);
      }

      function createAttentionMechanism() {
        const group = new THREE.Group();
        group.position.set(-6, 0, 0);

        // Definir constantes al inicio
        const numHeads = 8;
        const radius = 4;
        const headSize = 0.4;
        const particleCount = 100;

        // Crear el anillo exterior que representa el contexto
        const ringGeometry = new THREE.TorusGeometry(radius, 0.1, 16, 100);
        const ringMaterial = new THREE.MeshPhongMaterial({
          color: 0xffe66d,
          transparent: true,
          opacity: 0.3,
        });
        const contextRing = new THREE.Mesh(ringGeometry, ringMaterial);
        group.add(contextRing);

        // Crear las cabezas de atenci√≥n
        for (let i = 0; i < numHeads; i++) {
          const angle = (i / numHeads) * Math.PI * 2;

          // Cabeza de atenci√≥n (Query)
          const headGeometry = new THREE.ConeGeometry(
            headSize,
            headSize * 2,
            8
          );
          const headMaterial = new THREE.MeshPhongMaterial({
            color: 0xffe66d,
            emissive: 0xffe66d,
            emissiveIntensity: 0,
          });

          const head = new THREE.Mesh(headGeometry, headMaterial);
          head.position.set(
            Math.cos(angle) * radius,
            Math.sin(angle) * radius,
            0
          );
          head.rotation.z = angle + Math.PI / 2;
          head.userData = {
            type: "attention_head",
            index: i,
            component: "attention",
            angle: angle,
          };

          group.add(head);

          // Crear el campo de atenci√≥n para cada cabeza
          const attentionFieldGeometry = new THREE.CircleGeometry(
            radius * 0.8,
            32
          );
          const attentionFieldMaterial = new THREE.MeshPhongMaterial({
            color: 0xffe66d,
            transparent: true,
            opacity: 0,
            side: THREE.DoubleSide,
          });

          const attentionField = new THREE.Mesh(
            attentionFieldGeometry,
            attentionFieldMaterial
          );
          attentionField.rotation.x = Math.PI / 2;
          attentionField.position.z = -0.1;
          attentionField.userData = {
            type: "attention_field",
            headIndex: i,
            component: "attention",
          };

          group.add(attentionField);

          // Crear l√≠neas de atenci√≥n din√°micas
          for (let j = 0; j < numHeads; j++) {
            if (i !== j) {
              const targetAngle = (j / numHeads) * Math.PI * 2;
              const curve = new THREE.CubicBezierCurve3(
                new THREE.Vector3(
                  Math.cos(angle) * radius,
                  Math.sin(angle) * radius,
                  0
                ),
                new THREE.Vector3(
                  Math.cos(angle) * radius * 1.2,
                  Math.sin(angle) * radius * 1.2,
                  radius * 0.5
                ),
                new THREE.Vector3(
                  Math.cos(targetAngle) * radius * 1.2,
                  Math.sin(targetAngle) * radius * 1.2,
                  radius * 0.5
                ),
                new THREE.Vector3(
                  Math.cos(targetAngle) * radius,
                  Math.sin(targetAngle) * radius,
                  0
                )
              );

              const points = curve.getPoints(50);
              const lineGeometry = new THREE.BufferGeometry().setFromPoints(
                points
              );
              const lineMaterial = new THREE.LineBasicMaterial({
                color: 0xffe66d,
                opacity: 0,
                transparent: true,
              });

              const line = new THREE.Line(lineGeometry, lineMaterial);
              line.userData = {
                type: "attention_line",
                from: i,
                to: j,
                component: "attention",
                curve: curve,
              };

              group.add(line);
            }
          }
        }

        // A√±adir part√≠culas para representar el flujo de informaci√≥n
        const particleGeometry = new THREE.BufferGeometry();
        const particlePositions = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount; i++) {
          const angle = Math.random() * Math.PI * 2;
          const particleRadius = Math.random() * radius * 0.8;
          particlePositions[i * 3] = Math.cos(angle) * particleRadius;
          particlePositions[i * 3 + 1] = Math.sin(angle) * particleRadius;
          particlePositions[i * 3 + 2] = (Math.random() - 0.5) * 0.5;
        }

        particleGeometry.setAttribute(
          "position",
          new THREE.BufferAttribute(particlePositions, 3)
        );

        const particleMaterial = new THREE.PointsMaterial({
          color: 0xffe66d,
          size: 0.1,
          transparent: true,
          opacity: 0.6,
        });

        const particles = new THREE.Points(particleGeometry, particleMaterial);
        particles.userData = {
          type: "attention_particles",
          component: "attention",
        };

        group.add(particles);

        components.attention.group = group;
        components.attention.particles = particles;
        scene.add(group);
      }

      function createNeuralNetwork() {
        const group = new THREE.Group();
        group.position.set(14, 0, 0);

        const layers = [];
        const layerSizes = [8, 12, 16, 12, 8];
        const layerSpacing = 6;

        // Crear neuronas por capa
        for (let l = 0; l < layerSizes.length; l++) {
          const layer = [];
          const layerSize = layerSizes[l];
          const xOffset = (l - (layerSizes.length - 1) / 2) * layerSpacing;

          for (let n = 0; n < layerSize; n++) {
            const angle = (n / layerSize) * Math.PI * 2;
            const radius = 3 + layerSize / 8;

            const geometry = new THREE.SphereGeometry(0.3, 16, 16);
            const material = new THREE.MeshPhongMaterial({
              color: new THREE.Color().setHSL(0.6 - l * 0.1, 0.7, 0.5),
              emissive: new THREE.Color().setHSL(0.6 - l * 0.1, 0.7, 0.3),
              emissiveIntensity: 0,
            });

            const neuron = new THREE.Mesh(geometry, material);
            neuron.position.set(
              xOffset,
              Math.sin(angle) * radius,
              Math.cos(angle) * radius
            );

            neuron.userData = {
              type: "neuron",
              layer: l,
              index: n,
              activation: 0,
              component: "neural",
            };

            group.add(neuron);
            layer.push(neuron);
          }

          layers.push(layer);
        }

        // Crear conexiones entre capas
        const connectionMaterial = new THREE.LineBasicMaterial({
          color: 0x4a9eff,
          opacity: 0.13,
          transparent: true,
        });

        for (let l = 0; l < layers.length - 1; l++) {
          const currentLayer = layers[l];
          const nextLayer = layers[l + 1];

          currentLayer.forEach((neuron1, i) => {
            nextLayer.forEach((neuron2, j) => {
              if (Math.random() > 0.25) {
                const geometry = new THREE.BufferGeometry().setFromPoints([
                  neuron1.position,
                  neuron2.position,
                ]);

                const connection = new THREE.Line(
                  geometry,
                  connectionMaterial.clone()
                );
                connection.userData = {
                  type: "connection",
                  from: neuron1,
                  to: neuron2,
                  strength: Math.random(),
                  component: "neural",
                };

                group.add(connection);
              }
            });
          });
        }

        components.neural.group = group;
        components.neural.layers = layers;
        scene.add(group);
      }

      function createOutputLayer() {
        const group = new THREE.Group();
        group.position.set(32, 0, 0);

        // Crear nodos de salida
        const outputSize = 10;

        for (let i = 0; i < outputSize; i++) {
          const geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
          const material = new THREE.MeshPhongMaterial({
            color: 0xa8e6cf,
            emissive: 0xa8e6cf,
            emissiveIntensity: 0,
          });

          const output = new THREE.Mesh(geometry, material);
          output.position.set(0, i * 1.2 - 5, 0);
          output.userData = {
            type: "output",
            index: i,
            probability: 0,
            component: "output",
          };

          group.add(output);
        }

        components.output.group = group;
        scene.add(group);
      }

      function setupMouseControls() {
        let mouseX = 0,
          mouseY = 0;

        document.addEventListener("mousemove", (event) => {
          mouseX = (event.clientX / window.innerWidth) * 2 - 1;
          mouseY = -(event.clientY / window.innerHeight) * 2 + 1;

          // Rotaci√≥n suave de la c√°mara
          camera.position.x = mouseX * 5;
          camera.position.y = mouseY * 3;
          camera.lookAt(scene.position);
        });

        // Zoom con rueda del rat√≥n
        document.addEventListener("wheel", (event) => {
          camera.position.z += event.deltaY * 0.01;
          camera.position.z = Math.max(15, Math.min(50, camera.position.z));
        });
      }

      function setupEventListeners() {
        // Cambio de modo
        document.querySelectorAll(".mode-btn").forEach((btn) => {
          btn.addEventListener("click", (e) => {
            document
              .querySelectorAll(".mode-btn")
              .forEach((b) => b.classList.remove("active"));
            e.target.classList.add("active");
            mode = e.target.dataset.mode;
            updateVisualizationMode();
          });
        });

        // Controles de componentes
        document.querySelectorAll(".component-btn").forEach((btn) => {
          btn.addEventListener("click", (e) => {
            const component = e.target.dataset.component;
            components[component].visible = !components[component].visible;
            e.target.classList.toggle("active");

            if (components[component].group) {
              components[component].group.visible =
                components[component].visible;
            }
          });
        });

        // Controles deslizantes
        document
          .getElementById("layer-visibility")
          .addEventListener("input", (e) => {
            const visibleLayers = parseInt(e.target.value);
            if (components.neural.layers) {
              components.neural.layers.forEach((layer, index) => {
                layer.forEach((neuron) => {
                  neuron.visible = index < visibleLayers;
                });
              });
            }
          });

        document
          .getElementById("animation-speed")
          .addEventListener("input", (e) => {
            animationSpeed = parseFloat(e.target.value);
          });

        document
          .getElementById("connection-threshold")
          .addEventListener("input", (e) => {
            const threshold = parseFloat(e.target.value);
            if (components.neural.group) {
              components.neural.group.children.forEach((child) => {
                if (child.userData.type === "connection") {
                  child.visible = child.userData.strength > threshold;
                }
              });
            }
          });

        // Procesamiento de texto
        document
          .getElementById("process-btn")
          .addEventListener("click", processText);
        document
          .getElementById("text-input")
          .addEventListener("keypress", (e) => {
            if (e.key === "Enter") processText();
          });
      }

      function updateVisualizationMode() {
        if (mode === "student") {
          // Modo estudiante: visualizaci√≥n m√°s simple y educativa
          Object.values(components).forEach((comp) => {
            if (comp.group) {
              comp.group.children.forEach((child) => {
                if (child.material) {
                  child.material.wireframe = false;
                  if (child.userData.type === "connection") {
                    child.material.opacity = 0.05;
                  }
                }
              });
            }
          });
        } else {
          // Modo investigador: m√°s detalles t√©cnicos
          Object.values(components).forEach((comp) => {
            if (comp.group) {
              comp.group.children.forEach((child) => {
                if (child.material) {
                  if (child.userData.type === "neuron") {
                    child.material.wireframe = true;
                  }
                  if (child.userData.type === "connection") {
                    child.material.opacity = 0.1;
                  }
                }
              });
            }
          });
        }
      }

      function processText() {
        const text = document.getElementById("text-input").value;
        if (!text || isProcessing) return;

        isProcessing = true;

        // Simular tokenizaci√≥n
        const tokens = text.split(/\s+/);
        document.getElementById("token-count").textContent = tokens.length;

        // Animar el procesamiento a trav√©s de los componentes
        animateFullPipeline(tokens);
      }

      function animateFullPipeline(tokens) {
        let stage = 0;
        const stages = [
          () => animateTokenizer(tokens),
          () => animateEmbedding(),
          () => animateAttention(),
          () => animateNeuralNetwork(),
          () => animateOutput(),
        ];

        function nextStage() {
          if (stage < stages.length) {
            stages[stage]();
            stage++;
            setTimeout(nextStage, 1000 / animationSpeed);
          } else {
            isProcessing = false;
          }
        }

        nextStage();
      }

      function animateTokenizer(tokens) {
        if (!components.tokenizer.visible || !components.tokenizer.group)
          return;

        components.tokenizer.group.children.forEach((token, index) => {
          if (index < tokens.length) {
            const delay = index * 100;
            setTimeout(() => {
              animateObject(token, 0, 2, 500);
            }, delay);
          }
        });
      }

      function animateEmbedding() {
        if (!components.embedding.visible || !components.embedding.group)
          return;

        document.getElementById("embedding-info").textContent = "512D ‚úì";

        const points = components.embedding.group.children.filter(
          (child) => child.userData.type === "embedding"
        );

        points.forEach((point, index) => {
          const delay = index * 5;
          setTimeout(() => {
            // Animar el punto
            animateObject(point, 0, 1.5, 300);

            // A√±adir un peque√±o movimiento aleatorio
            const originalPos = point.userData.originalPosition;
            const randomOffset = new THREE.Vector3(
              (Math.random() - 0.5) * 0.2,
              (Math.random() - 0.5) * 0.2,
              (Math.random() - 0.5) * 0.2
            );

            point.position.copy(originalPos).add(randomOffset);

            // Devolver a la posici√≥n original despu√©s de la animaci√≥n
            setTimeout(() => {
              point.position.copy(originalPos);
            }, 300);
          }, delay);
        });
      }

      function animateAttention() {
        if (!components.attention.visible || !components.attention.group)
          return;

        const heads = components.attention.group.children.filter(
          (child) => child.userData.type === "attention_head"
        );

        const attentionFields = components.attention.group.children.filter(
          (child) => child.userData.type === "attention_field"
        );

        const attentionLines = components.attention.group.children.filter(
          (child) => child.userData.type === "attention_line"
        );

        // Animar cada cabeza de atenci√≥n
        heads.forEach((head, index) => {
          setTimeout(() => {
            // Animar la cabeza
            animateObject(head, 0, 2, 400);

            // Animar el campo de atenci√≥n correspondiente
            const field = attentionFields.find(
              (f) => f.userData.headIndex === index
            );
            if (field) {
              field.material.opacity = 0.2;
              setTimeout(() => {
                field.material.opacity = 0;
              }, 500);
            }

            // Animar las l√≠neas de atenci√≥n
            if (mode === "researcher") {
              const lines = attentionLines.filter(
                (line) => line.userData.from === index
              );

              lines.forEach((line) => {
                line.material.opacity = 0.3;
                setTimeout(() => {
                  line.material.opacity = 0;
                }, 500);
              });
            }
          }, index * 100);
        });

        const attentionScore = Math.round(Math.random() * 30 + 60);
        document.getElementById(
          "attention-score"
        ).textContent = `${attentionScore}%`;
      }

      function animateNeuralNetwork() {
        if (!components.neural.visible || !components.neural.layers) return;

        let currentLayer = 0;

        function processLayer() {
          if (currentLayer >= components.neural.layers.length) return;

          document.getElementById("layers-processed").textContent = `${
            currentLayer + 1
          }/${components.neural.layers.length}`;

          const layer = components.neural.layers[currentLayer];

          layer.forEach((neuron, index) => {
            const activation = Math.random();
            neuron.userData.activation = activation;

            setTimeout(() => {
              animateObject(neuron, 0, activation * 2, 300);
            }, index * 20);
          });

          const activeNeurons = Math.round(
            layer.length * 0.3 + Math.random() * layer.length * 0.4
          );
          document.getElementById("active-neurons").textContent = activeNeurons;

          currentLayer++;
          setTimeout(processLayer, 400 / animationSpeed);
        }

        processLayer();
      }

      function animateOutput() {
        if (!components.output.visible || !components.output.group) return;

        const outputs = components.output.group.children;
        const probs = outputs.map(() => Math.random());
        const sum = probs.reduce((a, b) => a + b, 0);

        outputs.forEach((output, index) => {
          const probability = probs[index] / sum;
          output.userData.probability = probability;

          setTimeout(() => {
            animateObject(output, 0, probability * 3, 400);
          }, index * 50);
        });

        const confidence = Math.round((Math.max(...probs) / sum) * 100);
        document.getElementById("confidence").textContent = `${confidence}%`;
      }

      function animateObject(
        object,
        initialIntensity,
        targetIntensity,
        duration
      ) {
        if (!object.material) return;

        const start = performance.now();
        const material = object.material;

        function updateAnimation(time) {
          const elapsed = time - start;
          const progress = Math.min(elapsed / duration, 1);

          material.emissiveIntensity =
            initialIntensity + (targetIntensity - initialIntensity) * progress;

          if (progress < 1) {
            requestAnimationFrame(updateAnimation);
          } else {
            setTimeout(() => {
              const fadeStart = performance.now();
              function fade(time) {
                const fadeProgress = Math.min(
                  (time - fadeStart) / (duration / 2),
                  1
                );
                material.emissiveIntensity =
                  targetIntensity * (1 - fadeProgress);

                if (fadeProgress < 1) {
                  requestAnimationFrame(fade);
                }
              }
              requestAnimationFrame(fade);
            }, 200);
          }
        }

        requestAnimationFrame(updateAnimation);
      }

      function animate() {
        requestAnimationFrame(animate);

        // Rotaci√≥n suave de las capas
        if (components.neural.layers) {
          components.neural.layers.forEach((layer) => {
            layer.forEach((neuron) => {
              neuron.rotation.y += 0.001 * animationSpeed;
            });
          });
        }

        // Rotaci√≥n suave del mecanismo de atenci√≥n
        if (components.attention.group) {
          components.attention.group.rotation.z += 0.001 * animationSpeed;

          // Animar part√≠culas
          if (components.attention.particles) {
            const positions =
              components.attention.particles.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
              const angle = Math.atan2(positions[i + 1], positions[i]);
              const radius = Math.sqrt(
                positions[i] * positions[i] +
                  positions[i + 1] * positions[i + 1]
              );

              // Mover part√≠culas en espiral
              positions[i] = Math.cos(angle + 0.01) * radius;
              positions[i + 1] = Math.sin(angle + 0.01) * radius;
              positions[i + 2] = Math.sin(Date.now() * 0.001 + i) * 0.2;
            }
            components.attention.particles.geometry.attributes.position.needsUpdate = true;
          }
        }

        // Rotaci√≥n suave del cubo de embedding
        if (components.embedding.group) {
          components.embedding.group.rotation.y += 0.002 * animationSpeed;
          components.embedding.group.rotation.x += 0.001 * animationSpeed;
        }

        // Actualizar controles de √≥rbita
        if (window.orbitControls) orbitControls.update();

        renderer.render(scene, camera);
      }

      // Ajustar al cambiar tama√±o de ventana
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Inicializar
      init();

      function checkHover(event) {
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(scene.children, true);
        if (intersects.length > 0) {
          const object = intersects[0].object;
          if (object.userData.type && hoveredObject !== object) {
            hoveredObject = object;
            showTooltip(event, object.userData);
          }
        } else {
          hideTooltip();
          hoveredObject = null;
        }
      }
      function showTooltip(event, data) {
        const tooltip = document.getElementById("tooltip");
        let content = "";
        switch (data.type) {
          case "token":
            content = `<strong>Token ${data.index}</strong><br />
      Cada palabra se convierte en un token num√©rico que el modelo puede procesar.`;
            break;
          case "embedding":
            content = `<strong
        >Embedding [${data.row},${data.col}]</strong
      ><br />
      Representaci√≥n vectorial que captura el significado sem√°ntico.`;
            break;
          case "attention_head":
            content = `<strong>Cabeza de Atenci√≥n ${data.index}</strong
      ><br />
      Analiza relaciones entre diferentes partes del texto.`;
            break;
          case "neuron":
            content = `<strong>Neurona [Capa ${data.layer}]</strong><br />
      Procesa y transforma la informaci√≥n. Activaci√≥n: ${(
        data.activation * 100
      ).toFixed(1)}%`;
            break;
          case "output":
            content = `<strong
        >Salida ${data.index}</strong
      ><br />
      Probabilidad de la siguiente palabra: ${(data.probability * 100).toFixed(
        1
      )}%`;
            break;
        }
        tooltip.innerHTML = content;
        tooltip.style.left = event.clientX + 10 + "px";
        tooltip.style.top = event.clientY + 10 + "px";
        tooltip.style.opacity = "1";
      }

      function hideTooltip() {
        const tooltip = document.getElementById("tooltip");
        tooltip.style.opacity = "0";
      }
    </script>
  </body>
</html>
